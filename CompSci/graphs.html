<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Graph Algorithms | Signal in the Static</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
    <meta name="description" content="Blog, notes and other stuff">
    <link rel="preload" href="/CompSci/assets/css/0.styles.f0c15ea1.css" as="style"><link rel="preload" href="/CompSci/assets/js/app.9e595c6c.js" as="script"><link rel="preload" href="/CompSci/assets/js/2.5c45e0ed.js" as="script"><link rel="preload" href="/CompSci/assets/js/28.48ffd611.js" as="script"><link rel="preload" href="/CompSci/assets/js/17.a8ef3d4e.js" as="script"><link rel="prefetch" href="/CompSci/assets/js/10.e96b1f78.js"><link rel="prefetch" href="/CompSci/assets/js/11.15d03fe7.js"><link rel="prefetch" href="/CompSci/assets/js/12.607376ad.js"><link rel="prefetch" href="/CompSci/assets/js/13.2d52ef55.js"><link rel="prefetch" href="/CompSci/assets/js/14.4e09b710.js"><link rel="prefetch" href="/CompSci/assets/js/15.cd08dde9.js"><link rel="prefetch" href="/CompSci/assets/js/16.e43851b2.js"><link rel="prefetch" href="/CompSci/assets/js/18.1fd4aa25.js"><link rel="prefetch" href="/CompSci/assets/js/19.27c9549f.js"><link rel="prefetch" href="/CompSci/assets/js/20.f3d7487c.js"><link rel="prefetch" href="/CompSci/assets/js/21.0f4e4779.js"><link rel="prefetch" href="/CompSci/assets/js/22.dc34a5f5.js"><link rel="prefetch" href="/CompSci/assets/js/23.96743339.js"><link rel="prefetch" href="/CompSci/assets/js/24.7d200d47.js"><link rel="prefetch" href="/CompSci/assets/js/25.d52b2fff.js"><link rel="prefetch" href="/CompSci/assets/js/26.39e3da81.js"><link rel="prefetch" href="/CompSci/assets/js/27.e7ac0606.js"><link rel="prefetch" href="/CompSci/assets/js/29.89d9f5d0.js"><link rel="prefetch" href="/CompSci/assets/js/3.22b48287.js"><link rel="prefetch" href="/CompSci/assets/js/30.c7929813.js"><link rel="prefetch" href="/CompSci/assets/js/31.4cd2b34f.js"><link rel="prefetch" href="/CompSci/assets/js/32.15bba6fe.js"><link rel="prefetch" href="/CompSci/assets/js/33.44b8035d.js"><link rel="prefetch" href="/CompSci/assets/js/34.72d2463c.js"><link rel="prefetch" href="/CompSci/assets/js/35.93ecf406.js"><link rel="prefetch" href="/CompSci/assets/js/36.022ed979.js"><link rel="prefetch" href="/CompSci/assets/js/37.51b69b2f.js"><link rel="prefetch" href="/CompSci/assets/js/38.3f3eaf3a.js"><link rel="prefetch" href="/CompSci/assets/js/39.e51c39ad.js"><link rel="prefetch" href="/CompSci/assets/js/4.dee1fbce.js"><link rel="prefetch" href="/CompSci/assets/js/40.271b9cf3.js"><link rel="prefetch" href="/CompSci/assets/js/41.1ec9ae84.js"><link rel="prefetch" href="/CompSci/assets/js/42.0045f715.js"><link rel="prefetch" href="/CompSci/assets/js/43.bcbb53c5.js"><link rel="prefetch" href="/CompSci/assets/js/44.b487d58b.js"><link rel="prefetch" href="/CompSci/assets/js/45.af1b4170.js"><link rel="prefetch" href="/CompSci/assets/js/46.836577ad.js"><link rel="prefetch" href="/CompSci/assets/js/47.7b7d0ca6.js"><link rel="prefetch" href="/CompSci/assets/js/48.3381c289.js"><link rel="prefetch" href="/CompSci/assets/js/49.36ffec01.js"><link rel="prefetch" href="/CompSci/assets/js/5.a67417c4.js"><link rel="prefetch" href="/CompSci/assets/js/50.c8e7b2b9.js"><link rel="prefetch" href="/CompSci/assets/js/51.ae26fa97.js"><link rel="prefetch" href="/CompSci/assets/js/52.c9ca1a44.js"><link rel="prefetch" href="/CompSci/assets/js/53.c071273a.js"><link rel="prefetch" href="/CompSci/assets/js/54.5cfee169.js"><link rel="prefetch" href="/CompSci/assets/js/55.355cf329.js"><link rel="prefetch" href="/CompSci/assets/js/56.59278406.js"><link rel="prefetch" href="/CompSci/assets/js/57.411a8c7f.js"><link rel="prefetch" href="/CompSci/assets/js/58.1af08036.js"><link rel="prefetch" href="/CompSci/assets/js/59.ee63cff6.js"><link rel="prefetch" href="/CompSci/assets/js/6.4ad1abc3.js"><link rel="prefetch" href="/CompSci/assets/js/60.c6504db4.js"><link rel="prefetch" href="/CompSci/assets/js/61.83cf62e1.js"><link rel="prefetch" href="/CompSci/assets/js/7.59e2630f.js"><link rel="prefetch" href="/CompSci/assets/js/8.3720b895.js"><link rel="prefetch" href="/CompSci/assets/js/9.02ee38a7.js">
    <link rel="stylesheet" href="/CompSci/assets/css/0.styles.f0c15ea1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/CompSci/" class="home-link router-link-active"><!----> <span class="site-name">Signal in the Static</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/CompSci/" class="nav-link">Home</a></div><div class="nav-item"><a href="/CompSci/blog/" class="nav-link">Blog</a></div><div class="nav-item"><a href="/CompSci/about/" class="nav-link">About</a></div> <div class="nav-item"><a role="button" aria-label="Switch to light mode" class="nav-link"><span>Switch theme</span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/CompSci/" class="nav-link">Home</a></div><div class="nav-item"><a href="/CompSci/blog/" class="nav-link">Blog</a></div><div class="nav-item"><a href="/CompSci/about/" class="nav-link">About</a></div> <div class="nav-item"><a role="button" aria-label="Switch to light mode" class="nav-link"><span>Switch theme</span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/CompSci/blog/" class="sidebar-link">Blog</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Notes</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/CompSci/Books/" class="sidebar-heading clickable"><span>Books</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/CompSci/CompSci/" class="sidebar-heading clickable router-link-active open"><span>CompSci</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/CompSci/CompSci/bigO.html" class="sidebar-link">Big O &amp; Algorithms</a></li><li><a href="/CompSci/CompSci/bigO_basics.html" class="sidebar-link">Big O Notation</a></li><li><a href="/CompSci/CompSci/concepts.html" class="sidebar-link">Interesting concepts</a></li><li><a href="/CompSci/CompSci/cs_snippets.html" class="sidebar-link">CS Snippets</a></li><li><a href="/CompSci/CompSci/dynamic_programming.html" class="sidebar-link">Dynamic Programming</a></li><li><a href="/CompSci/CompSci/graphs.html" aria-current="page" class="active sidebar-link">Graph Algorithms</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/CompSci/CompSci/graphs.html#topological-sort" class="sidebar-link">Topological Sort</a></li><li class="sidebar-sub-header"><a href="/CompSci/CompSci/graphs.html#dfs-bfs-iddfs" class="sidebar-link">DFS, BFS, IDDFS</a></li><li class="sidebar-sub-header"><a href="/CompSci/CompSci/graphs.html#uninformed-shortest-path-dijkstra-and-floyd-warshall" class="sidebar-link">Uninformed Shortest Path: Dijkstra and Floyd-Warshall</a></li><li class="sidebar-sub-header"><a href="/CompSci/CompSci/graphs.html#informed-search-a" class="sidebar-link">Informed Search: A*</a></li><li class="sidebar-sub-header"><a href="/CompSci/CompSci/graphs.html#ida" class="sidebar-link">IDA*</a></li><li class="sidebar-sub-header"><a href="/CompSci/CompSci/graphs.html#bidirectional-search" class="sidebar-link">Bidirectional Search</a></li><li class="sidebar-sub-header"><a href="/CompSci/CompSci/graphs.html#minimax-alpha-beta-pruning" class="sidebar-link">Minimax, Alpha-Beta Pruning</a></li><li class="sidebar-sub-header"><a href="/CompSci/CompSci/graphs.html#minimum-spanning-tree-prim-s-algorithm" class="sidebar-link">Minimum Spanning Tree: Prim's Algorithm</a></li><li class="sidebar-sub-header"><a href="/CompSci/CompSci/graphs.html#more-graph-problems" class="sidebar-link">More Graph Problems</a></li></ul></li><li><a href="/CompSci/CompSci/heaps.html" class="sidebar-link">Heaps</a></li><li><a href="/CompSci/CompSci/linked_lists.html" class="sidebar-link">Linked Lists</a></li><li><a href="/CompSci/CompSci/networking.html" class="sidebar-link">Networking</a></li><li><a href="/CompSci/CompSci/software_design_principles.html" class="sidebar-link">Software design principles</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/CompSci/Math/" class="sidebar-heading clickable"><span>Math</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/CompSci/Programming/" class="sidebar-heading clickable"><span>Programming</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-solarized-content content__default"><h1 id="graph-algorithms"><a href="#graph-algorithms" class="header-anchor">#</a> Graph Algorithms</h1> <p></p><div class="table-of-contents"><ul><li><a href="#topological-sort">Topological Sort</a></li><li><a href="#dfs-bfs-iddfs">DFS, BFS, IDDFS</a></li><li><a href="#uninformed-shortest-path-dijkstra-and-floyd-warshall">Uninformed Shortest Path: Dijkstra and Floyd-Warshall</a></li><li><a href="#informed-search-a">Informed Search: A*</a></li><li><a href="#ida">IDA*</a></li><li><a href="#bidirectional-search">Bidirectional Search</a></li><li><a href="#minimax-alpha-beta-pruning">Minimax, Alpha-Beta Pruning</a></li><li><a href="#minimum-spanning-tree-prim-s-algorithm">Minimum Spanning Tree: Prim's Algorithm</a></li><li><a href="#more-graph-problems">More Graph Problems</a></li></ul></div><p></p> <p>[TOC]</p> <hr> <h2 id="topological-sort"><a href="#topological-sort" class="header-anchor">#</a> Topological Sort</h2> <p>Boring. Count the number of in edges and store in a hash. Each round, pick a vertex with no in edges. That's the next vertex. Decrement the vertices which have an in edge here. <code>O(|V| + |E|)</code>.</p> <h2 id="dfs-bfs-iddfs"><a href="#dfs-bfs-iddfs" class="header-anchor">#</a> DFS, BFS, IDDFS</h2> <p>DFS can be implemented with a stack, BFS with a queue.</p> <p>BFS is optimal, and will eventually find a solution if it exists (<em>complete</em>). DFS is not necessarily optimal, and in an infinite graph can go down a wrong path forever; it also has problems with loops.</p> <p>DFS is much better at memory usage: it runs proportional to depth of the tree, while BFS uses <code>O(b^d')</code> memory, where <code>d'</code> is depth of the best solution.</p> <p>You can fix the BFS space problem by running iterative-deepening DFS, which just performs a depth-limited DFS search for increasing depths. This is a complete and optimal solution. Also, since most vertices are at the last level, this still runs in <code>O(b^d')</code> time!</p> <p><strong>Backtracking</strong></p> <ul><li>You can give up on a branch if you realize it can't possibly lead to success.</li></ul> <h2 id="uninformed-shortest-path-dijkstra-and-floyd-warshall"><a href="#uninformed-shortest-path-dijkstra-and-floyd-warshall" class="header-anchor">#</a> Uninformed Shortest Path: Dijkstra and Floyd-Warshall</h2> <p>Dijkstra's algorithm just grows paths by adding path extensions one at a time. There are three approaches:</p> <ul><li>Keep track of best paths to all <code>V</code> vertices: <code>O(E + V**2)</code>.</li> <li>Use a binary heap: <code>O((E + V) * log(V))</code>.
<ul><li>Worse for dense graphs.</li></ul></li> <li>Use a Fibonacci heap: <code>O(E + V * log(V))</code>.
<ul><li>Updates are cheap!</li> <li>Best of both worlds, except probably slower than either because Fib heaps are slow and complicated.</li></ul></li></ul> <p>If you want to find all-pairs shortest paths, you can run Dijkstra's <code>V</code> times. However, if you have a dense graph, you might also use the Floyd-Warshal algorithm:</p> <ul><li>Dynamic programming algorithm that loosens a constraint of only traveling through a subset of vertices.</li> <li><code>V</code> runs: each time, you select a vertex, updating <code>V**2</code> paths.</li></ul> <p>In a dense graph, Floyd-Warshall has better practical performance than Dijkstra. But for a sparse graph the repeated Fibonacci Dijkstra is better. <em>Except that Floyd-Warshall can deal with negative edges</em>.</p> <p>Since I don't give a shit, I don't talk about <em>Bellman-Ford</em> or <em>Johnson's Algorithm</em>, which can handle <strong>negative cycles</strong>. Fuck that.</p> <p>In the case of trees with a branching factor of <code>b</code>, then the longest path you must consider is of length <code>C/eps</code>, where <code>eps</code> is a lower bound on the cost of an edge, while <code>C</code> is the cost of the best path. Therefore, we can take <code>V=C/eps</code>.</p> <h2 id="informed-search-a"><a href="#informed-search-a" class="header-anchor">#</a> Informed Search: A*</h2> <p><strong>A*</strong> is a souped-up Dijkstra's algorithm. It requires an <em>admissable heuristic</em>: one which is optimistic about the distance from a vertex to the target. In the priority queue, we take into acount not only the path's cost, but the expected further distance to travel to a goal node.</p> <p>Generally speaking, this is the same as Dijkstra, which just has a heuristic of <code>0</code>. The algorithm is complete and optimal. It will give up on bad paths eventually as it slowly realizes the heuristic was optimistic.</p> <p><strong>Correction:</strong> You need a <em>consistent</em> (AKA monotone) heuristic. This one has the property that:</p> <div class="language- extra-class"><pre><code>h(n) &lt;= c(n, n') + h(n')
</code></pre></div><p>for all successors <code>n'</code> of <code>n</code>. The reason this is important is that when you expand a node, you need to know that you were considering not just what you think is the probable best path to the target, but in fact <em>the best path to that interior node</em>.</p> <p><strong>Result</strong>: When the search is in a tree AND the error of the heuristic function is logarithmic, then the time complexity is polynomial! <strong>TODO2: Prove me!</strong></p> <p>Note that A* is optimal for any heuristic searching out from the root, because it needs to consider exactly those paths it considers, lest it miss a shortcut to the target. Of course, there are other possible algorithms that don't just start from the root...</p> <p>NB: A heuristic that dominates another (<code>h_2(n) &gt; h_1(n)</code> for all <code>n</code>) will yield better performance, assuming of course it is still acceptable.</p> <h2 id="ida"><a href="#ida" class="header-anchor">#</a> IDA*</h2> <p>Both Dijkstra and A* both suffer from very large memory requirements. Another approach is to modify IDDFS to use a heuristic. In this case, you set a <code>bound</code> for total path cost; you then search in a DFS manner, abandoning a path when the heuristic total cost <code>g(a) + h(a)</code> greater than the bound.</p> <p>Like IDDFS, this runs in multiple rounds. Start the bound at zero. Abandon paths as above; but also keep track of the cost of the minimum abandoned path. In the next round, use this cost as the new bound to ensure progress.</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">IDAStarSolver</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">run</span></span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
    bound <span class="token operator">=</span> h<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    loop <span class="token keyword">do</span>
      result <span class="token operator">=</span> search<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bound<span class="token punctuation">)</span>
      <span class="token keyword">return</span> result<span class="token punctuation">[</span><span class="token symbol">:found</span><span class="token punctuation">]</span> <span class="token keyword">if</span> result<span class="token punctuation">.</span>has_key<span class="token operator">?</span><span class="token punctuation">(</span><span class="token symbol">:found</span><span class="token punctuation">)</span>
      bound <span class="token operator">=</span> result <span class="token punctuation">[</span><span class="token symbol">:abandonment_cost</span><span class="token punctuation">]</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">search</span></span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> cost<span class="token punctuation">,</span> bound<span class="token punctuation">)</span>
    <span class="token keyword">if</span> cost <span class="token operator">+</span> h<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&gt;</span> bound
      <span class="token comment"># Abandon this route!</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> abandonment_cost<span class="token punctuation">:</span> cost <span class="token operator">+</span> h<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token keyword">end</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span> found<span class="token punctuation">:</span> node <span class="token punctuation">}</span> <span class="token keyword">if</span> is_goal<span class="token operator">?</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>

    abandonment_cost <span class="token operator">=</span> <span class="token keyword">nil</span>
    node<span class="token punctuation">.</span>out_edges<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>edge<span class="token operator">|</span>
      new_cost <span class="token operator">=</span> cost <span class="token operator">+</span> edge<span class="token punctuation">.</span>cost
      result <span class="token operator">=</span> search<span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to_vertex<span class="token punctuation">,</span> new_cost<span class="token punctuation">,</span> bound<span class="token punctuation">)</span>

      <span class="token comment"># May have found it!</span>
      <span class="token keyword">return</span> result <span class="token keyword">if</span> result<span class="token punctuation">.</span>has_key<span class="token operator">?</span><span class="token punctuation">(</span><span class="token symbol">:found</span><span class="token punctuation">)</span>
      <span class="token comment"># May have given up!</span>
      <span class="token keyword">if</span> abandonment_cost<span class="token punctuation">.</span><span class="token keyword">nil</span><span class="token operator">?</span> <span class="token operator">||</span> result<span class="token punctuation">[</span><span class="token symbol">:abandonment_cost</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> abandonment_cost
        abandonment_cost <span class="token operator">=</span> result<span class="token punctuation">[</span><span class="token symbol">:abandonment_cost</span><span class="token punctuation">]</span>
      <span class="token keyword">end</span>
    <span class="token keyword">end</span>

    <span class="token keyword">return</span> abandonment_cost
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>This returns an optimal path, with much reduced memory usage (proportionate) to length path. However, it may have higher computational overhead because of the necessity of revisiting nodes. It also in some sense doesn't use enough memory; it just remembers a ceiling heuristic value.</p> <p>An alternative is <strong>SMA*</strong>, which expands the graph at the leaves in an <code>A*</code> manner. When it runs out of space, it drops the low cost leaf, writing into its parent that we should return when we've explored all nodes of lower cost. The parent can be added to the &quot;leaf&quot; set. In this way, we don't need to keep revisiting early parts of the tree as we do in <code>IDA*</code>.</p> <h2 id="bidirectional-search"><a href="#bidirectional-search" class="header-anchor">#</a> Bidirectional Search</h2> <p>Start from both ends and work toward the others. When you link up, you have a path. You can use BFS or IDDFS in which case the result will be optimal. You need to keep one of the fringes in memory, so space usage is <code>O(b^d)</code> if we're talking a tree.</p> <p>On the other hand, you can use A* targeting the other source. It seems that the result may not be optimal. There is also a concept of &quot;front-to-front&quot; search where a heuristic exists to move toward the <em>front</em>, and not the *back*. This may be optimal. However, this is pretty expensive.</p> <h2 id="minimax-alpha-beta-pruning"><a href="#minimax-alpha-beta-pruning" class="header-anchor">#</a> Minimax, Alpha-Beta Pruning</h2> <p>Minimax strategy is to make the best move, assuming your opponent makes the worst move for you and you respond with the best. Basically, you try to maximize, then they try to minimize...</p> <p>You can of course do this to completion with a <code>+1</code> for winning and a <code>-1</code> for losing (and maybe a <code>0</code> for drawing). This of course doesn't work for deep game trees, so we use heuristics to guide the search. For instance, look 12 moves ahead and then apply the heuristic.</p> <p>Imagine that the minimizing player sees they can force a loss by taking the first branch of the move tree from a given position. Then there is no need to consider the other branches. Alpha-Beta pruning extends this logic. If the maximizing player sees they can force a score of <code>x</code> on the first branch, then they need to check the other branches. However, as soon as the minimizing player realizes they can force a score less than <code>x</code>, they can abandon this path, because things can only get worse for the maximizer, and thus they will not take this path.</p> <p>Let alpha be the maximum score that the maximizer knows they can force, where beta is the minimum score that the minimizer knows they can force. As the search plays out, alpha and beta will approach each other until they become equal. To start, alpha may be <code>-1</code> and <code>+1</code>, since we know that the maximizer can't do worse that lose, and vice-versa.</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">search</span></span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> player<span class="token punctuation">,</span> depth<span class="token punctuation">,</span> alpha<span class="token punctuation">,</span> beta<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">,</span> heuristic<span class="token punctuation">:</span> h<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">if</span> depth <span class="token operator">==</span> <span class="token number">0</span>

  <span class="token keyword">if</span> player <span class="token operator">==</span> <span class="token boolean">true</span>
    <span class="token comment"># Try to maximize!</span>
    max_path<span class="token punctuation">,</span> max_path_score <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token punctuation">,</span> <span class="token keyword">nil</span>
    node<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>child<span class="token operator">|</span>
      path<span class="token punctuation">,</span> path_score <span class="token operator">=</span> search<span class="token punctuation">(</span>
        child<span class="token punctuation">,</span>
        <span class="token boolean">false</span><span class="token punctuation">,</span>
        depth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
        alpha<span class="token punctuation">,</span>
        beta
      <span class="token punctuation">)</span><span class="token punctuation">.</span>values_at<span class="token punctuation">(</span><span class="token symbol">:path</span><span class="token punctuation">,</span> <span class="token symbol">:heuristic</span><span class="token punctuation">)</span>

      <span class="token keyword">next</span> <span class="token keyword">if</span> path<span class="token punctuation">.</span><span class="token keyword">nil</span><span class="token operator">?</span>

      <span class="token comment"># Is this the best move we've seen so far?</span>
      <span class="token keyword">if</span> max_path_score<span class="token punctuation">.</span><span class="token keyword">nil</span><span class="token operator">?</span> <span class="token operator">||</span> path_score <span class="token operator">&gt;</span> max_path_score
        max_path<span class="token punctuation">,</span> max_path_score <span class="token operator">=</span> path<span class="token punctuation">,</span> max_path_score
      <span class="token keyword">end</span>

      <span class="token comment"># If considering a branch where the opponent can force a result</span>
      <span class="token comment"># worse than alpha, forget it, since this is the better option.</span>
      <span class="token keyword">if</span> alpha <span class="token operator">&lt;</span> path_score
        alpha <span class="token operator">=</span> path_score

        <span class="token comment"># Beta was previously set to the worst result the opponent</span>
        <span class="token comment"># could force. But now we see that if the opponent must never</span>
        <span class="token comment"># allow us to move to node, because then the maximizer could</span>
        <span class="token comment"># force a better result.</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> abandoned<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token keyword">if</span> beta <span class="token operator">&lt;</span> alpha
      <span class="token keyword">end</span>
    <span class="token keyword">end</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span> path<span class="token punctuation">:</span> max_path<span class="token punctuation">,</span> heuristic<span class="token punctuation">:</span> max_path_score <span class="token punctuation">}</span>
  <span class="token keyword">else</span>
    <span class="token comment"># Analogous!</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><h2 id="minimum-spanning-tree-prim-s-algorithm"><a href="#minimum-spanning-tree-prim-s-algorithm" class="header-anchor">#</a> Minimum Spanning Tree: Prim's Algorithm</h2> <p>Just stupid Dijkstra's. Doesn't take into account of existing path, just the cost of the next edge. Same performance characteristics.</p> <p>Kruskal's Algorithm is apparently more performant in sparse graphs, though has same time bounds. It uses union-find datastructure which seems boring.</p> <p>Bor≈Øvka's algorithm is apparently very parallelizable. Could actually be interesting. <strong>Todo</strong></p> <h2 id="more-graph-problems"><a href="#more-graph-problems" class="header-anchor">#</a> More Graph Problems</h2> <ul><li>Johnson's Algorithm allows faster all-pairs shortest path <em>on sparse graphs</em>.</li> <li>Min cut</li> <li>Smallest max-edge path</li> <li>Largest min-edge path</li> <li>K-shortest paths</li> <li>Clique detection</li> <li>Embedding</li> <li>Strongly Connected components</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/10/2020, 9:41:26 PM</span></div></footer> <!----> </main></div><div class="global-ui"><div style="visibility:hidden;display:none;"></div></div></div>
    <script src="/CompSci/assets/js/app.9e595c6c.js" defer></script><script src="/CompSci/assets/js/2.5c45e0ed.js" defer></script><script src="/CompSci/assets/js/28.48ffd611.js" defer></script><script src="/CompSci/assets/js/17.a8ef3d4e.js" defer></script>
  </body>
</html>
